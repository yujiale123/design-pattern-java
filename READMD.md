# 设计模式

## 设计模式六大原则

### 开闭原则

开闭原则（Open-Closed Principle, OCP），是指一个软件实体类、模块和函数对扩展开发，对修改关闭。

开闭就是对扩展和修改两个行为的一个原则，同时是面向对象设计中最基础的设计原则。主要指导我们建立稳定灵活的系统。

一般情况下，功能添加，不对原功能的源代码进行修改，新增一个修改方法进行代码编写。

### 单一职责原则

单一职责原则（Simple Responsibility Pinciple，SRP），是指一个类和方法只负责做一件事情。

单一职责原则可以使后期需求变更维修互不影响。可以降低类的复杂度，提高了类的可读性，降低变更引用的风向。

总的来说就是一 个 Class/Interface/Method 只负责一项职责

### 里氏替换原则

里氏替换原则（Liskov Substitution Principle，LSP）是指如果对每一个类型为T1的对象o1，都有类型为T2的对象O2，
使得以T1定义的所有程序P在所有的对象O1都替换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。

总的来说：

- 子类可以扩展父类的功能，但是不能改变父类的功能。
- 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
- 子类除了实现父类的方法之外，还可以增加自己的特有方法。
- 当子类的方法重载父类方法时，方法的入参要比父类方法的入参更加宽松。
- 当子类的方法实现父类方法时（重写/重载或实现抽象方法），方法的返回值要比父类相等活着严格

优点：

- 约束继承泛滥
- 加强程序的健壮性，同时在变更时也做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更引入的风险，

### 依赖倒置原则

依赖倒置原则（Dependence Inversion Proncipe，DTP），是指设计代码结构时，高层模块不应该依赖底层模式，都应该依赖其抽象。

抽象不依赖细节，细节依赖抽象。

通过依赖倒置原则可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低修改程序所造成的风险。

### 接口隔离原则

接口隔离原则 （ Interface Segregation Principle, ISP），是指用多个专门的接口来进行功能区分，而不是用一个接口来当作是总接口。

客户端只需要依赖需要的接口，不需要依赖其他的接口

注意事项：

- 一个类对一个类的依赖应该是建立在最小的接口之上
- 尽量创建单一接口，不要让接口臃肿
- 尽量细化接口，接口中的方法尽量少（适度）

接口隔离原则符合**高内聚低耦合**的设计思想， 从而使得类具有很好的可读性、可扩展性 和可维护性。

### 迪米特原则

迪米特原则（Law of Demeter，LoD），是指一个对象对其他对象保持最少知道。也叫做最少知道原则。尽量降低类与类之间的耦合。

迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类， 而出现在方法体内部的类不属于朋友类。

## 创建型模式

### 工厂模式

工厂模式也被称为工厂方法模式，是一种创造型模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。 主要意图是定义一个创建对象的接口，让其子类决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

为了提供代码结构的扩展性，屏蔽每⼀个功能类中的具体实现逻辑。

工厂模式分为简单工厂模式和工厂方法模式

- 简单工厂适用于工厂类负责创建的对象**较少**的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。 简单工厂违背了开闭原则，同时对于工厂的扩展不易。
  简单工厂只需要创建一个正确的参数，就可以获得所需要的对象，不需要考虑创建的细节。

- 工厂方法模式 (Factory Method Pattern) 是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，
  工厂方法让类的实例化推迟到子类中进行。在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符合开闭原则。

  工厂方法主要适用场景
    - 创建对象需要大量重复代码
    - 客户端(应用层)不依赖于产品类实例如何被创建、实现等细节。
    - 一个类通过子类来指定创建那些对象

  工厂方法缺点

    - 类的个数繁多，增加系统复杂度
    - 增加了系统的抽象性和阅读难度

  工厂方法角色

    - 抽象角色
    - 抽象工厂
    - 实现角色（具体角色）
    - 实现工厂（具体工厂）

### 抽象工厂模式

抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖的接口，且访问类无须指定所要产品的具体类就能得到同族的不同登记的产品模式结构

使用抽象工厂条件

- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品
- 系统一次只可能消费某一族的产品，即同一族的产品一起使用

优点

- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
- 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
- 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

缺点

- 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度

角色

- 抽象工厂 提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
- 具体工厂 主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
- 抽象产品 定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
- 具体产品 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。

使用场景

- 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
- 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
- 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构

### 建造者模式

建造者模式将一个复杂对象的构建与他表示分离同样的构建过程可以有不同的表示。一个 Builder 类会一步一步构建复杂的对象，允许用户指通过指定复杂对象的类型和内容 构构建，用户不需要知道内部构建的具体细节，独立于其他对象。

复杂对象是指那些包含多个成员属性的对象； 这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件

建造者模式的最终意图，也就是； 将⼀个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

优点

- 建造类独立，易扩展
- 可以控制细节和风险 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
  每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。
  由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合 “开闭原则”。 可以更加精细地控制产品的创建过程。
  将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

缺点

- 产品必须有共同点，范围有限制。
- 如内部变化复杂，会有很多的建造类。

建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。

使用场景

- 需要生成的对象具有复杂的结构
- 需要生成的对象内部属性本身互相依赖

需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。
在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

角色

- 抽象建造者

它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()
，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。

- 具体建造者

  它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。
- 产品

  它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。
  
- 指挥者

  指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()
  建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。

### 原型模式

### 单例模式

## 结构型模式

### 适配器模式

### 桥接模式

### 组合模式

### 装饰器模式

### 外观模式

### 代理模式

### 享元模式

## 行为型模式

### 责任链模式

### 命令模式

### 迭代器模式

### 中介者模式

### 备忘录模式

### 观察者模式

### 状态模式

### 策略模式

### 模版方法模式

### 访问者模式
