# 设计模式

## 设计模式六大原则

### 开闭原则

开闭原则（Open-Closed Principle, OCP），是指一个软件实体类、模块和函数对扩展开发，对修改关闭。

开闭就是对扩展和修改两个行为的一个原则，同时是面向对象设计中最基础的设计原则。主要指导我们建立稳定灵活的系统。

一般情况下，功能添加，不对原功能的源代码进行修改，新增一个修改方法进行代码编写。

### 单一职责原则

单一职责原则（Simple Responsibility Pinciple，SRP），是指一个类和方法只负责做一件事情。

单一职责原则可以使后期需求变更维修互不影响。可以降低类的复杂度，提高了类的可读性，降低变更引用的风向。

总的来说就是一 个 Class/Interface/Method 只负责一项职责

### 里氏替换原则

里氏替换原则（Liskov Substitution Principle，LSP）是指如果对每一个类型为T1的对象o1，都有类型为T2的对象O2，
使得以T1定义的所有程序P在所有的对象O1都替换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。

总的来说：

- 子类可以扩展父类的功能，但是不能改变父类的功能。
- 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
- 子类除了实现父类的方法之外，还可以增加自己的特有方法。
- 当子类的方法重载父类方法时，方法的入参要比父类方法的入参更加宽松。
- 当子类的方法实现父类方法时（重写/重载或实现抽象方法），方法的返回值要比父类相等活着严格

优点：

- 约束继承泛滥
- 加强程序的健壮性，同时在变更时也做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更引入的风险，

### 依赖倒置原则

依赖倒置原则（Dependence Inversion Proncipe，DTP），是指设计代码结构时，高层模块不应该依赖底层模式，都应该依赖其抽象。

抽象不依赖细节，细节依赖抽象。

通过依赖倒置原则可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低修改程序所造成的风险。

### 接口隔离原则

接口隔离原则 （ Interface Segregation Principle, ISP），是指用多个专门的接口来进行功能区分，而不是用一个接口来当作是总接口。

客户端只需要依赖需要的接口，不需要依赖其他的接口

注意事项：

- 一个类对一个类的依赖应该是建立在最小的接口之上
- 尽量创建单一接口，不要让接口臃肿
- 尽量细化接口，接口中的方法尽量少（适度）

接口隔离原则符合**高内聚低耦合**的设计思想， 从而使得类具有很好的可读性、可扩展性 和可维护性。

### 迪米特原则

迪米特原则（Law of Demeter，LoD），是指一个对象对其他对象保持最少知道。也叫做最少知道原则。尽量降低类与类之间的耦合。

迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类， 而出现在方法体内部的类不属于朋友类。

## 创建型模式

### 工厂模式

工厂模式也被称为工厂方法模式，是一种创造型模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。 主要意图是定义一个创建对象的接口，让其子类决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

为了提供代码结构的扩展性，屏蔽每⼀个功能类中的具体实现逻辑。

工厂模式分为简单工厂模式和工厂方法模式

- 简单工厂适用于工厂类负责创建的对象**较少**的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。 简单工厂违背了开闭原则，同时对于工厂的扩展不易。
  简单工厂只需要创建一个正确的参数，就可以获得所需要的对象，不需要考虑创建的细节。

- 工厂方法模式 (Factory Method Pattern) 是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，
  工厂方法让类的实例化推迟到子类中进行。在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符合开闭原则。

  工厂方法主要适用场景
    - 创建对象需要大量重复代码
    - 客户端(应用层)不依赖于产品类实例如何被创建、实现等细节。
    - 一个类通过子类来指定创建那些对象

  工厂方法缺点

    - 类的个数繁多，增加系统复杂度
    - 增加了系统的抽象性和阅读难度

  工厂方法角色

    - 抽象角色
    - 抽象工厂
    - 实现角色（具体角色）
    - 实现工厂（具体工厂）

### 抽象工厂模式

抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖的接口，且访问类无须指定所要产品的具体类就能得到同族的不同登记的产品模式结构

使用抽象工厂条件

- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品
- 系统一次只可能消费某一族的产品，即同一族的产品一起使用

优点

- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
- 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
- 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

缺点

- 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度

角色

- 抽象工厂 提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
- 具体工厂 主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
- 抽象产品 定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
- 具体产品 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。


使用场景

- 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
- 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
- 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构

### 建造者模式


### 原型模式

### 单例模式

## 结构型模式

### 适配器模式

### 桥接模式

### 组合模式

### 装饰器模式

### 外观模式

### 代理模式

### 享元模式

## 行为型模式

### 责任链模式

### 命令模式

### 迭代器模式

### 中介者模式

### 备忘录模式

### 观察者模式

### 状态模式

### 策略模式

### 模版方法模式

### 访问者模式
